<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PrepAura Nexus — Chat</title>

  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="practice-tool.css" />
  <link rel="stylesheet" href="chatbot.css" />
  <style>
    /* chat page additional styles (cyberpunk blue-cyan) */
    body { background: linear-gradient(180deg,#05060b,#071029); color: #e6f2ff; }
    .chat-wrap {
      max-width: 920px;
      margin: 80px auto;
      padding: 20px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(6,10,20,0.6), rgba(4,6,12,0.65));
      border: 1px solid rgba(58,183,255,0.06);
      box-shadow: 0 20px 60px rgba(2,6,23,0.7);
      min-height: 560px;
    }

    .chat-header {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 12px;
      margin-bottom: 14px;
    }
    .chat-header h2 { margin:0; font-size:1.2rem; color:#dff8ff; }
    .chat-header .sub { color:#9fb9ff; font-size:0.9rem; opacity:.95 }

    .chat-body {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding: 16px;
      border-radius: 10px;
      height: 380px;
      overflow:auto;
      border: 1px solid rgba(255,255,255,0.02);
      margin-bottom: 12px;
    }

    .msg { margin-bottom: 12px; display:flex; gap:10px; align-items:flex-start; }
    .msg.user { justify-content:flex-end; }
    .bubble {
      max-width:76%;
      padding: 12px 14px;
      border-radius: 12px;
      line-height:1.4;
      font-size:0.95rem;
      white-space: pre-wrap;
    }
    .bubble.ai {
      background: linear-gradient(180deg, rgba(58,183,255,0.08), rgba(124,77,255,0.03));
      border:1px solid rgba(58,183,255,0.06);
      color:#e7f7ff;
      box-shadow: 0 8px 30px rgba(56,168,255,0.04);
      border-top-left-radius:4px;
    }
    .bubble.user {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      color:#ffffff;
      align-self:flex-end;
      border-bottom-right-radius:4px;
    }

    .chat-controls { display:flex; gap:10px; align-items:center; }
    .chat-controls input[type="text"] {
      flex:1;
      padding:12px 14px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.04);
      background:#071029;
      color:#e6f2ff;
      font-size:0.98rem;
    }
    .chat-controls button {
      padding:10px 14px;
      border-radius:10px;
      border:none;
      font-weight:700;
      background: linear-gradient(90deg,#3ab7ff,#7c4dff);
      color:white;
      cursor:pointer;
    }

    .meta-note { font-size:0.85rem; color:#9fb9ff; margin-top:10px; }
    .typing { color:#9fb9ff; font-size:0.95rem; margin-left:6px; }

    /* mobile */
    @media (max-width:720px) {
      .chat-wrap { margin: 40px 12px; }
      .chat-body { height: 320px; }
    }
  </style>
</head>
<body>

  <main class="chat-wrap">
    <div class="chat-header">
      <div>
        <h2>PrepAura Nexus</h2>
        <div class="sub">Cyberpunk Assistant — Your Personal Guide cum Assistant</div>
      </div>
      <div>
        <button onclick="location.href='practice.html'" class="btn-ghost">Back</button>
      </div>
    </div>

    <div id="chatBody" class="chat-body" aria-live="polite"></div>

    <div class="chat-controls">
      <input id="chatInput" type="text" placeholder="Ask Nexus Anything" />
      <button id="sendBtn">Send</button>
    </div>

    <div class="meta-note">
      Responses are powered via Gemini.
      <span id="typingIndicator" class="typing" style="display:none">Nexus is typing…</span>
    </div>
  </main>

  <script>
    // chat-page script: minimal, uses /api/gemini backend
    (function(){
      const chatBody = document.getElementById('chatBody');
      const input = document.getElementById('chatInput');
      const sendBtn = document.getElementById('sendBtn');
      const typing = document.getElementById('typingIndicator');

      // chat.html: inside (function(){...})

    let currentAIBubble = null; // Variable to hold the reference to the current streaming bubble

    function appendMsg(text, who='ai', isNewMessage=true) {
      let displayText = text.replace(/<\/?p>/gi, '');

      if (isNewMessage) {
          // Create a new bubble for the start of a message
          const wrap = document.createElement('div');
          wrap.className = 'msg ' + (who === 'user' ? 'user' : 'ai');
          const bubble = document.createElement('div');
          bubble.className = 'bubble ' + (who === 'user' ? 'user' : 'ai');

          if (who === 'ai' && !displayText) {
             displayText = "<em>Nexus is thinking...</em>";
          }

          bubble.innerHTML = displayText;
          wrap.appendChild(bubble);
          chatBody.appendChild(wrap);
          
          if (who === 'ai') {
              currentAIBubble = bubble; // Store the reference
          }
          // AFTER FIX
          } else if (currentAIBubble && who === 'ai') {
            // Get the cleaned text chunk
            const cleanedChunk = text.replace(/<\/?p>/gi, '');

            // ⭐️ FIX: Check if the bubble still contains the "thinking" text
            if (currentAIBubble.innerHTML.includes("Nexus is thinking...")) {
              // Overwrite the temporary message with the first real chunk
              currentAIBubble.innerHTML = cleanedChunk;
            } else {
              // Append subsequent chunks as normal
              currentAIBubble.innerHTML += cleanedChunk;
            }
        } else {
          // Fallback for non-streaming user messages
          const wrap = document.createElement('div');
          wrap.className = 'msg ' + (who === 'user' ? 'user' : 'ai');
          const bubble = document.createElement('div');
          bubble.className = 'bubble ' + (who === 'user' ? 'user' : 'ai');
          bubble.innerHTML = text;
          wrap.appendChild(bubble);
          chatBody.appendChild(wrap);
      }
      chatBody.scrollTop = chatBody.scrollHeight;
    }

      // chat.html: replace existing sendQuestion
    async function sendQuestion(q) {
        if (!q || q.trim()==='') return;
        
        // User message is a new message
        appendMsg(q, 'user');
        input.value = '';
        typing.style.display = 'inline';
        sendBtn.disabled = true;

        // Start a new AI bubble for streaming (passing the first chunk as empty)
        appendMsg("", 'ai', true); 

        try {
            // We use fetch here to send the POST data first.
            // The endpoint is still the same, but it now returns an event stream.
            const req = await fetch("https://prepmate-backend-x77z.onrender.com/api/gemini", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ prompt: q })
            });
            
            if (!req.ok) {
                const text = await req.text();
                appendMsg("⚠️ Error: " + req.status + " — " + (text || req.statusText), 'ai', false); // Update existing bubble
                return;
            }

            // Get the reader from the streamed response body
            const reader = req.body.getReader();
            const decoder = new TextDecoder("utf-8");
            
            let done = false;
            let buffer = "";

            while (!done) {
                const { value, done: streamDone } = await reader.read();
                done = streamDone;
                
                if (value) {
                    buffer += decoder.decode(value, { stream: true });
                    
                    // Process the buffer for complete SSE events
                    let events = buffer.split('\n\n');
                    buffer = events.pop(); // Keep the potentially incomplete last chunk in the buffer

                    for (let event of events) {
                        if (event.startsWith('data: ')) {
                            const data = event.substring(6); // Remove 'data: ' prefix
                            
                            if (data === '[DONE]') {
                                // End of stream signal
                                done = true;
                                break;
                            }
                            if (data.startsWith('[ERROR]')) {
                                // Handle error sent from backend stream
                                appendMsg(data, 'ai', false);
                                done = true;
                                break;
                            }

                            // Append the new chunk to the existing AI bubble
                            appendMsg(data, 'ai', false); 
                        }
                    }
                }
            }
            
            // Final cleanup after stream is complete
            currentAIBubble = null;

        } catch (err) {
            console.error(err);
            appendMsg("⚠️ Network error. Check backend or internet.", 'ai', false);
        } finally {
            typing.style.display = 'none';
            sendBtn.disabled = false;
        }
    }
      sendBtn.addEventListener('click', ()=> sendQuestion(input.value));
      input.addEventListener('keydown', (e)=> { if(e.key === 'Enter') sendQuestion(input.value); });

      // welcome message
      appendMsg("⚡ <strong>Nexus Ready</strong><br>What Can I Help You With Today?");
    })();
  </script>
</body>
</html>